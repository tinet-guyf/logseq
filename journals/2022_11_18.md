- ((6376eced-9da0-4815-b7e9-b3b05919e413))
	- Channel：可以看做是数据载体，连接接发数据的两段。
	- 回调：方法调用的一种方式。
	- Future：异步操作的结果的占位符。
	- 事件和 ChannelHandler：
		- 事件包括：
		  连接已被激活或者连接失活；
		  数据读取
		  用户事件
		  错误事件
		  打开或者关闭到远程节点的连接
		  将数据写到或者冲刷到套接字
		- 每个事件都可以被分发给 ChannelHandler 类中的某个用户实现的方法。
-
- ((637735fe-ea83-4120-8715-12166c2bdb72))
	- 至少一个 ChannelHandler：封装业务逻辑
	  ChannelInboundHandlerAdapter ：
	  1. channelRead()— 对于每个传入的消息都要调用；
	  2. channelReadComplete()—通知 ChannelInboundHandler 最后一次对 channel-Read()的调用完成后的处理。
	  3. exceptionCaught()— 在读取操作期间，有异常抛出时会调用。
	- 引导服务器
	  1. 创建一个ServerBootstrap的实例以**引导和绑定服务器**；
	  2. 创建并分配一个 NioEventLoopGroup 实例以进行**事件的处理**，如接受新连接以及读/写数据；
	  3. 指定服务器绑定的本地的 InetSocketAddress；
	  4. 使用一个 ServerHandler 的实例**初始化每一个新的 Channel**；
	  5. 调用 ServerBootstrap.bind()方法以绑定服务器。
-
- ((63773b70-0f0f-47e8-8728-199956ee895a))
	- 和服务端类似，一个ChannelHandler和以一个引导程序。
	- SimpleChannelInboundHandler：
	  1. channelActive()——在到服务器的连接已经建立之后将被调用；
	  2. channelRead0()——当从服务器接收到一条消息时被调用；
	  3. exceptionCaught()——在处理过程中引发异常时被调用。
	  
	  #+BEGIN_NOTE
	  消息有可能被拆包或粘包，就会导致发送次数不固定。但对TCP来说会保证消息的顺序。
	  #+END_NOTE
	  
	  #+BEGIN_QUOTE
	  SimpleChannelInboundHandler 与 ChannelInboundHandler区别：
	  主要因为业务逻辑**如何处理消息**以及 Netty 如何**管理资源**。
	  SCH继承CH。channelRead0()方法完成时，会释放ByteBuf内存。而在服务端读完数据之后还要发送给客户端，不能释放byteBuf内存，channelRead()方法不会释放ByteBuf内存；手动调用writeAndFlush()方法时被释放。
	  
	  #+END_QUOTE
	- 客户端引导
	  1. 为初始化客户端，创建了一个 Bootstrap 实例；
	  2. 为进行事件处理分配了一个 NioEventLoopGroup 实例，服务端和客户端可以使用不同的IOEventLoop
	  3. 为服务器连接创建了一个 InetSocketAddress 实例；
	  4. 当连接被建立时，一个 EchoClientHandler 实例会被安装到（该 Channel 的）ChannelPipeline 中；
	  5. 在一切都设置完成后，调用 Bootstrap.connect()方法连接到远程节点；
-
-
-